/*
 * Spoofax-Lua: a Lua Eclipse plugin based on Spoofax
 * Copyright (C) 2011  Tobi Vollebregt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
module type-analysis

imports
  include/Lua
  lib/editor-common.generated

signature
  constructors
    Boolean  : Boolean
    Number   : Number
    String   : String
    Table    : String -> Table
    Function : String -> Function
    Minus    : Exp * Exp -> Exp
    Minus    : Exp -> Exp

strategies

/*
ObjectId dynamic rule maps
- AST elements to their ObjectId
- Field(ObjectId, String) to its ObjectId
- Index(ObjectId, String) to its ObjectId

Goal of this type analysis is to calculate for each renamed variable the union
of all possible types this variable might have.
*/

  type-analysis-top =
    with(
      alltd(assign-oid);
      alltd(assign-oid-complete)
      // DEBUG
      ;<debug> "=== ObjectId ===";
      all-keys-ObjectId;
      list-loop(<debug(!"ObjectId: ")> (<id>, <bagof-ObjectId>));
      <debug> "=== TableField ===";
      all-keys-TableField;
      list-loop(<debug(!"TableField: ")> (<id>, <bagof-TableField>))
      // END DEBUG
    )

rules

  assign-oid: LocalVariableDecl(name*, exp*) -> <id>
    with
      <alltd(assign-oid)> exp*;
      <zipPad(assignment-assign-oid, !None())> (name*, exp*)

  assign-oid: Assignment(var*, exp*) -> <id>
    with
      <alltd(assign-oid)> exp*;
      <zipPad(assignment-assign-oid, !None())> (var*, exp*)

  assign-oid-complete: Field(exp, COMPLETION(_)) -> <get-oids>

rules

  // Assignment to a new variable
  assignment-assign-oid:
    (Name(name), exp-rhs) -> <id>
    where
      <get-oids; put-oids(|name)> exp-rhs

  // Assignment to an existing variable
  assignment-assign-oid:
    (Var(name), exp-rhs) -> <id>
    where
      <get-oids; put-oids(|name)> exp-rhs

  // Assignment to a field, e.g. `x.y = 1'
  assignment-assign-oid:
    (Field(exp-lhs, name), exp-rhs) -> <id>
    where
      oids-rhs := <get-oids> exp-rhs;
      <get-oids> exp-lhs;
      filter({tid:
        ?tid@Table(_);
        <put-oids(|Field(tid, name))> oids-rhs;
        rules( TableField :+ tid -> name )
      })

  // Assignment to an index, e.g. `x[1] = 2'
  assignment-assign-oid:
    (Index(exp-lhs, exp-index), exp-rhs) -> <id>
    where
      oids-index := <get-oids> exp-index;
      oids-rhs := <get-oids> exp-rhs;
      <get-oids> exp-lhs;
      filter({tid:
        ?tid@Table(_);
        !oids-index;
        list-loop({oid-index:
          ?oid-index;
          <put-oids(|Index(tid, oid-index))> oids-rhs
        })
      })

  // Error case: more expressions than variables given in assignment.
  assignment-assign-oid:
    (None(), exp-rhs) -> <id>

  put-oids(|t) =
    where( present-oids := <bagof-ObjectId> t );
    list-loop({oid: ?oid;
      (  <one(?oid)> present-oids
      <+ rules( ObjectId :+ t -> oid )  )
    })

rules

  // Error case: more variables than expressions given in assignment.
  get-oids: None() -> []

  get-oids: Nil()     -> [Nil()]
  get-oids: False()   -> [Boolean()]
  get-oids: True()    -> [Boolean()]
  get-oids: Number(_) -> [Number()]
  get-oids: String(_) -> [String()]

  // FIXME: Be smarter here...
  get-oids: VarArgs() -> []

  get-oids: Var(name) -> oids
    where
      if not(oids := <bagof-ObjectId; ?[_|_]> name) then
        // Yet unknown variable is assumed to be a table.
        oid := Table(<new>){"default"};
        oids := [oid];
        rules( ObjectId :+ name -> oid )
      end

  // Used for hover help; not used in the actual type analysis.
  get-oids: Name(name) -> <bagof-ObjectId> name

  // Binary operators with Number() result.
  // FIXME: ignoring operator overloading...
  get-oids: Plus  (_, _) -> [Number()]
  get-oids: Minus (_, _) -> [Number()]
  get-oids: Times (_, _) -> [Number()]
  get-oids: Divide(_, _) -> [Number()]
  get-oids: Power (_, _) -> [Number()]
  get-oids: Modulo(_, _) -> [Number()]

  // Binary operators with String() result.
  get-oids: Concat(_, _) -> [String()]

  // Binary operators with Boolean() result.
  get-oids: LowerThan  (_, _) -> [Boolean()]
  get-oids: GreaterThan(_, _) -> [Boolean()]
  get-oids: LowerThanOrEqual  (_, _) -> [Boolean()]
  get-oids: GreaterThanOrEqual(_, _) -> [Boolean()]
  get-oids: Equal   (_, _) -> [Boolean()]
  get-oids: NotEqual(_, _) -> [Boolean()]

  // And and Or return one of their arguments.
  get-oids: And(x, y) -> <conc> (<get-oids> x, <get-oids> y)
  get-oids: Or (x, y) -> <conc> (<get-oids> x, <get-oids> y)

  // Unary operators.
  get-oids: Minus(_) -> [Number()]
  get-oids: Not(_) -> [Boolean()]
  get-oids: Length(_) -> [Number()]

  get-oids: t@Field(exp, name) -> oids
    where
      <get-oids> exp;
      if !name => COMPLETION(_) then
        mapconcat(bagof-TableField) => proposals;
        rules( ContentProposals := proposals );
        oids := []
      else
        filter({oid,tid,x:
          ?tid@Table(_); // Only tables.
          x := Field(tid, name);
          (
            // If field known => return all known OIDs.
            bagof-ObjectId; ?[_ | _]
          <+
            // If field not known => store it. (with table type)
            oid := Table(<new>){"default"};
            rules(
              ObjectId   :+ x -> oid
              TableField :+ tid -> name
            );
            ![oid]
          )
        });
        concat => oids
      end

  get-oids: t@Index(exp, exp-index) -> oids
    where
      oids-index := <get-oids> exp-index;
      <get-oids> exp;
      filter({tid:
        ?tid@Table(_); // Only tables.
        <mapconcat(<bagof-ObjectId> Index(tid, <id>))> oids-index
      });
      concat => oids

  // TODO: implement this
  // should store parameter list (for completion)
  get-oids: Function(_, _) -> [Function(<new>)]
  // should get OIDs that function can return
  get-oids: FunctionCall(_, _) -> []

  get-oids: t@TableCons(field*) -> [tid]
    where
      if not(ObjectId => tid) then
        tid := Table(<new>);
        rules( ObjectId :+ t -> tid );
        <list-loop(put-field(|tid))> field*
      end

  put-field(|tid): ArrayField(exp) -> <id>
    where
      <get-oids> exp;
      // When table TID is indexed using a number, it might return OIDs.
      // NOTE: all indices are in the same equivalence class (number).
      put-oids(|Index(tid, Number()))

  put-field(|tid): KeyValueField(name, exp) -> <id>
    where
      <get-oids> exp;
      // When table TID is indexed using a string, it might return OIDs.
      put-oids(|Index(tid, String()));
      // When field NAME in table TID is accessed, it might return OIDs.
      put-oids(|Field(tid, name));
      // Table TID has field NAME, which stores OID.
      rules( TableField :+ tid -> name )

  put-field(|tid): CalculatedField(_, _) -> <id>
