module desugar

imports
  include/Lua
  lib/editor-common.generated

strategies

  desugar-top = innermost(origin-track-forced(desugar))

rules

  desugar:
    <is-list; one(is-list)> -> <flatten-list>

  desugar:
    Chunk(stat*, laststat) -> Chunk([stat*, laststat])

  desugar:
    Return(None()) -> Return([])

  desugar:
    Return(Some(t)) -> Return(t)

  desugar:
    ArgList(None()) -> []

  desugar:
    ArgList(Some(t)) -> t

  desugar:
    ArgTableCons(t) -> [t]

  desugar:
    ArgString(t) -> [String(t)]

  desugar:
    ArgRawString(t) -> [RawString(t)]

  desugar:
    ParList(t*) -> t*

  desugar:
    VarParList(t*) -> [t*, VarArgs()]

  desugar:
    TableCons(None()) -> TableCons([])

  desugar:
    TableCons(Some(FieldList(t*, _))) -> TableCons(<remove-all(is-int)> t*)

rules

  // always include optional step size with `for' loops
  desugar:
    ForLoop(a, b, c, d) -> ForLoop(a, b, c, Number("1"), d)

  // `x:z()' is sugar for `x.z(x)'
  desugar:
    MethodCall(path, name, args) -> FunctionCall(path', args')
    where
      path' := Field(path, name);
      args' := <conc> ([path], args)

  // `function x:z()...end' is sugar for `function x.z(self)...end'
  desugar:
    FunctionDecl(MethodName(path, name), Function(args, body)) ->
      FunctionDecl(FunctionName(path'), Function(args', body))
    where
      path' := <conc> (path, [name]);
      args' := <conc> ([Name("self")], args)

  // `function x.y.z()...end' is sugar for `x.y.z = function()...end'
  desugar:
    FunctionDecl(FunctionName(path), fun) ->
      Assignment([path'], [fun])
    where
      // FIXME I bet there is a strategy to do this in the library
      let cp = rec x(([y] -> Var(y)) <+ !Field(<init; x>, <last>)) in
        path' := <cp> path
      end

  // `local function x()...end' is sugar for `local x; x = function()...end'
  desugar:
    LocalFunctionDecl(name, fun) ->
      [
        LocalVariableDecl([Name(name)]),
        Assignment([Var(name)], [fun])
      ]
