module desugar

imports
  include/Lua

strategies

  desugar-top = innermost(desugar)

  desugar-top':
    x@File(_, _) -> y
    where
      y := <innermost(desugar)> x

  desugar:
    Chunk(s, ls) -> Chunk(t)
    where
      t := <conc> (s, [ls])

  // always include optional step size with `for' loops
  desugar:
    ForLoop(a, b, c, d) -> ForLoop(a, b, c, Number("1"), d)

  desugar:
    Return() -> Return([])

  // `x:z()' is sugar for `x.z(x)'
  desugar:
    MethodCall(path, name, args) -> FunctionCall(path', args')
    where
      path' := DirectTableAccess(path, name);
      args' := <conc> ([path], args)

  // `function x:z()...end' is sugar for `function x.z(self)...end'
  desugar:
    FunctionDecl(MethodName(path, name), Function(args, body)) ->
      FunctionDecl(FunctionName(path'), Function(args', body))
    where
      path' := <conc> (path, [name]);
      args' := <conc> ([Name("self")], args)

  // `function x.y.z()...end' is sugar for `x.y.z = function()...end' 
  desugar:
    FunctionDecl(FunctionName(path), fun){a*} ->
      Assignment([path'], [fun]){a*}
    where
      // FIXME I bet there is a strategy to do this in the library
      let cp = rec x(([y] -> Var(y)) <+ !DirectTableAccess(<init; x>, <last>)) in
        path' := <cp> path
      end

  // `local function x()...end' is sugar for `local x; x = function()...end'
/*
  desugar:
    LocalFunctionDecl(name, fun){a*} -> 
      [
        LocalVariableDecl([Name(name)]),
        Assignment([Var(name)], [fun]){a*}
      ]
*/
  desugar:
    |[ local function ~name(~args) ~*body end ]| ->
    *|[ local ~name ; ~name = function(~args) ~*body end ]|

/*
  desugar:
    Chunk(s) -> Chunk(t)
    where
      t := <flatten-list> s;
      not(<equal> (s, t))    // prevent infinite application of rule
*/

/*
  desugar:
    |[ ~*s ]| -> |[ ~*t ]|
    where
      t := <flatten-list> s;
      not(<equal> (s, t))    // prevent infinite application of rule
*/
